import {
  User,
  Manuscript,
  Paragraph,
  Collaborator,
  RoyaltyCalculation,
  BlockchainConfig,
  AIAnalysis,
  AISuggestion
} from '../types';

describe('Types', () => {
  describe('User interface', () => {
    test('should accept valid user object', () => {
      const validUser: User = {
        id: 'user-123',
        email: 'test@example.com',
        name: 'John Doe',
        subscriptionTier: 'pro',
        walletAddress: '0x1234567890123456789012345678901234567890',
        createdAt: new Date()
      };

      expect(validUser.id).toBe('user-123');
      expect(validUser.subscriptionTier).toBe('pro');
      expect(validUser.walletAddress).toBeDefined();
    });

    test('should work without optional walletAddress', () => {
      const userWithoutWallet: User = {
        id: 'user-456',
        email: 'test2@example.com',
        name: 'Jane Doe',
        subscriptionTier: 'free',
        createdAt: new Date()
      };

      expect(userWithoutWallet.walletAddress).toBeUndefined();
      expect(userWithoutWallet.subscriptionTier).toBe('free');
    });
  });

  describe('Manuscript interface', () => {
    test('should accept valid manuscript object', () => {
      const validManuscript: Manuscript = {
        id: 'manuscript-123',
        title: 'My Great Novel',
        genre: 'Fiction',
        wordCount: 50000,
        progress: 75,
        paragraphs: [],
        collaborators: [],
        rightsSecured: false
      };

      expect(validManuscript.title).toBe('My Great Novel');
      expect(validManuscript.progress).toBe(75);
      expect(validManuscript.rightsSecured).toBe(false);
    });

    test('should work with blockchain transaction hash', () => {
      const manuscriptWithTx: Manuscript = {
        id: 'manuscript-456',
        title: 'Blockchain Novel',
        genre: 'Sci-Fi',
        wordCount: 75000,
        progress: 100,
        paragraphs: [],
        collaborators: [],
        rightsSecured: true,
        blockchainTxHash: '0xabcdef1234567890'
      };

      expect(manuscriptWithTx.rightsSecured).toBe(true);
      expect(manuscriptWithTx.blockchainTxHash).toBeDefined();
    });
  });

  describe('Paragraph interface', () => {
    test('should accept human-authored paragraph', () => {
      const humanParagraph: Paragraph = {
        id: 'para-123',
        text: 'This is a paragraph written by a human author.',
        source: 'human',
        authorId: 'user-123',
        timestamp: new Date()
      };

      expect(humanParagraph.source).toBe('human');
      expect(humanParagraph.aiPrompt).toBeUndefined();
    });

    test('should accept AI-generated paragraph with prompt', () => {
      const aiParagraph: Paragraph = {
        id: 'para-456',
        text: 'This paragraph was generated by AI.',
        source: 'ai',
        aiPrompt: 'Write a dramatic scene',
        authorId: 'user-123',
        timestamp: new Date()
      };

      expect(aiParagraph.source).toBe('ai');
      expect(aiParagraph.aiPrompt).toBe('Write a dramatic scene');
    });
  });

  describe('Collaborator interface', () => {
    test('should accept collaborator with royalty share', () => {
      const collaborator: Collaborator = {
        userId: 'user-789',
        role: 'author',
        permissions: ['read', 'write', 'edit'],
        royaltyShare: 25
      };

      expect(collaborator.role).toBe('author');
      expect(collaborator.royaltyShare).toBe(25);
      expect(collaborator.permissions).toContain('write');
    });

    test('should work without royalty share', () => {
      const betaReader: Collaborator = {
        userId: 'user-999',
        role: 'beta-reader',
        permissions: ['read', 'comment']
      };

      expect(betaReader.role).toBe('beta-reader');
      expect(betaReader.royaltyShare).toBeUndefined();
    });
  });

  describe('RoyaltyCalculation interface', () => {
    test('should accept complete royalty calculation', () => {
      const calculation: RoyaltyCalculation = {
        platform: 'kdp',
        format: 'ebook',
        price: 9.99,
        royaltyRate: 0.7,
        platformFee: 5,
        authorEarnings: 6.49,
        projections: {
          monthly: { conservative: 100, moderate: 250, optimistic: 500 },
          annual: { conservative: 1200, moderate: 3000, optimistic: 6000 }
        }
      };

      expect(calculation.platform).toBe('kdp');
      expect(calculation.format).toBe('ebook');
      expect(calculation.projections.monthly.moderate).toBe(250);
    });
  });

  describe('BlockchainConfig interface', () => {
    test('should accept valid blockchain configuration', () => {
      const config: BlockchainConfig = {
        polygonWallet: '0x1234567890123456789012345678901234567890',
        baseWallet: '0x0987654321098765432109876543210987654321',
        solanaWallet: '3E8keZHkH1AHvRfbmq44tEmBgJYz1NjkhBE41C4gJHUn',
        platformFeePercentage: 5
      };

      expect(config.platformFeePercentage).toBe(5);
      expect(config.polygonWallet).toMatch(/^0x/);
    });
  });

  describe('AIAnalysis interface', () => {
    test('should accept complete AI analysis', () => {
      const analysis: AIAnalysis = {
        originality: 85,
        voiceMatch: 92,
        pacing: 78,
        engagement: 88,
        suggestions: []
      };

      expect(analysis.originality).toBe(85);
      expect(analysis.voiceMatch).toBe(92);
      expect(Array.isArray(analysis.suggestions)).toBe(true);
    });
  });

  describe('AISuggestion interface', () => {
    test('should accept valid AI suggestion', () => {
      const suggestion: AISuggestion = {
        id: 'suggestion-123',
        type: 'improve-style',
        text: 'Consider varying your sentence structure for better flow.',
        confidence: 0.85,
        reasoning: 'Multiple consecutive sentences have similar length and structure.'
      };

      expect(suggestion.type).toBe('improve-style');
      expect(suggestion.confidence).toBe(0.85);
      expect(suggestion.reasoning).toContain('structure');
    });

    test('should accept different suggestion types', () => {
      const expandSuggestion: AISuggestion = {
        id: 'suggestion-456',
        type: 'expand-scene',
        text: 'This scene could benefit from more sensory details.',
        confidence: 0.92,
        reasoning: 'Scene lacks descriptive elements that would enhance reader immersion.'
      };

      const characterSuggestion: AISuggestion = {
        id: 'suggestion-789',
        type: 'character-development',
        text: 'Consider adding more backstory for this character.',
        confidence: 0.78,
        reasoning: 'Character motivations are unclear in this context.'
      };

      expect(expandSuggestion.type).toBe('expand-scene');
      expect(characterSuggestion.type).toBe('character-development');
    });
  });

  describe('Type validation helpers', () => {
    test('subscription tiers should be valid', () => {
      const validTiers: Array<User['subscriptionTier']> = ['free', 'pro', 'enterprise'];
      
      validTiers.forEach(tier => {
        const user: User = {
          id: 'test',
          email: 'test@test.com',
          name: 'Test User',
          subscriptionTier: tier,
          createdAt: new Date()
        };
        expect(['free', 'pro', 'enterprise']).toContain(user.subscriptionTier);
      });
    });

    test('collaborator roles should be valid', () => {
      const validRoles: Array<Collaborator['role']> = ['author', 'editor', 'beta-reader'];
      
      validRoles.forEach(role => {
        const collaborator: Collaborator = {
          userId: 'test-user',
          role: role,
          permissions: ['read']
        };
        expect(['author', 'editor', 'beta-reader']).toContain(collaborator.role);
      });
    });

    test('platform types should be valid', () => {
      const validPlatforms: Array<RoyaltyCalculation['platform']> = ['kdp', 'neural-books', 'ingramspark'];
      
      validPlatforms.forEach(platform => {
        expect(['kdp', 'neural-books', 'ingramspark']).toContain(platform);
      });
    });

    test('format types should be valid', () => {
      const validFormats: Array<RoyaltyCalculation['format']> = ['ebook', 'paperback', 'hardcover', 'audiobook'];
      
      validFormats.forEach(format => {
        expect(['ebook', 'paperback', 'hardcover', 'audiobook']).toContain(format);
      });
    });
  });
});
